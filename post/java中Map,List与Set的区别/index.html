<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>java中Map,List与Set的区别 | itme.ink</title>
<meta name="description" content="温故而知新">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://jike-leisong.github.io//favicon.ico?v=1573183571074">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://jike-leisong.github.io//styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://jike-leisong.github.io/">
        <img src="https://jike-leisong.github.io//images/avatar.png?v=1573183571074" class="site-logo">
        <h1 class="site-title">itme.ink</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://jike-leisong.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">java中Map,List与Set的区别</h2>
            <div class="post-date">2017-12-23</div>
            
            <div class="post-content">
              <p>java集合的主要分为三种类型：</p>
<ul>
<li>Set（集）</li>
<li>List（列表）</li>
<li>Map（映射）</li>
</ul>
<p>要深入理解集合首先要了解下我们熟悉的数组：</p>
<blockquote>
<p>数组是大小固定的，并且同一个数组只能存放类型一样的数据（基本类型/引用类型），而Java集合可以存储和操作数目不固定的一组数据。所有Java集合位于java.util包中，Java集合只能存放 引用型的数据，不能存放 基本类型的数据。</p>
</blockquote>
<p>简单说下集合和数据的区别：</p>
<blockquote>
<ul>
<li>世间本来没有集合，（只有数组参考C语言），但有人想要，所以有了 集合</li>
<li>有人想有可以自动扩展的数组，所以有了 list</li>
<li>有的人想有没有重复的数组，所以有了 set</li>
<li>有人想要自动排序的数组，所以有了 TreeSet, TreeList, Tree**</li>
</ul>
<p>而几乎所有的集合都是基于数组来实现的<br>
因为集合是对数组进行的封装，所以，数组永远比任何一个集合要快</p>
<p>但任何一个集合，比数组提供的功能要多</p>
<ol>
<li>数组声明了它容纳的元素的类型，而集合不声明。这是由于集合以 object 形式来存储它们的元素</li>
<li>一个数组实例是有固定大小，不能伸缩。集合可根据需要动态改变大小</li>
<li>数组是一种可读/可写数据结构。没有办法创建一个只读数组。然而可以使用集合提供readonly方法，以只读方式来使用集合。该方法返回一个集合的只读版本。</li>
</ol>
</blockquote>
<p><font color="red">Java所有“存储及随机访问一连串对象”的做法，array是最有效率的一种。</font></p>
<ol>
<li>效率高，但容量固定且无法动态改变。array还有一个缺点：无法判断其中实际有多少元素，length只是告诉我们array的容量。</li>
<li>Java中有一个 Arrays类，专门用来操作 array。</li>
</ol>
<blockquote>
<p><strong>Arrays中拥有一个 static 函数:</strong><br>
equals: 比较俩个 array 是否相等。array拥有相同元素的个数，且所有对应元素两两相等<br>
fill(): 将值填入array中<br>
sort(): 用来对array进行排序<br>
binarySearch(): 在排好序的array中寻找元素<br>
System.arraycopy(): array的复制</p>
</blockquote>
<p>若撰写程序时不知道究竟需要多少对象，需要在空间不足时自动扩增容量，则需要使用容器类库，array不适用。所以就要用到集合。<br>
那我们开始讨论java中的集合。<br>
集合分类：</p>
<p><strong>Collection: List、Set</strong><br>
<strong>Map：HashMap、HashTable</strong></p>
<h4 id="collection接口">Collection接口</h4>
<p>Collection是最基本的集合接口，声明了适用于JAVA集合（只包括Set和List）的通用方法。 Set 和List 都继承了Conllection.Map。</p>
<p>Collection接口的方法：</p>
<blockquote>
<p>boolean add(Object o)：向集合中加入一个对象的引用<br>
void clear()：删除集合中所有的对象，即不再持有这些对象的引用<br>
boolean isEmpty()：判断集合是否为空<br>
boolean contains(Object o)：判断集合中是否持有特定对象的引用<br>
Iterartor iterator() ：返回一个Iterator对象，可以用来遍历集合中的元素<br>
boolean remove(Object o) ：从集合中删除一个对象的引用<br>
int size()：返回集合中元素的数目<br>
Object[] toArray()： 返回一个数组，该数组中包括集合中的所有元素</p>
</blockquote>
<p>关于：Iterator() 和toArray() 方法都用于集合的所有的元素，前者返回一个Iterator对象，后者返回一个包含集合中所有元素的数组。</p>
<p>Iterator接口声明了如下方法：</p>
<blockquote>
<p>hasNext()：判断集合中元素是否遍历完毕，如果没有，就返回true<br>
next() ：返回下一个元素<br>
remove()：从集合中删除上一个有next()方法返回的元素。</p>
</blockquote>
<h4 id="set集合">Set(集合)</h4>
<p>Set是最简单的一种集合。集合中的对象不按特定的方式排序，并且没有重复对象。 Set接口主要实现了两个实现类：</p>
<ul>
<li>HashSet： HashSet类按照哈希算法来存取集合中的对象，存取速度比较快</li>
<li>TreeSet ：TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。</li>
</ul>
<p><font color="red">Set 的用法：存放的是对象的引用，没有重复对象</font></p>
<pre><code class="language-java">Set set=new HashSet();  
 
String s1=new String(&quot;hello&quot;);  
 
String s2=s1;  
 
String s3=new String(&quot;world&quot;);  
 
set.add(s1);  
 
set.add(s2);  
 
set.add(s3);  
 
System.out.println(set.size());//打印集合中对象的数目 为 2。
</code></pre>
<p><font color="red">Set 的 add()方法是如何判断对象是否已经存放在集合中？</font></p>
<pre><code class="language-java">boolean isExists=false;  
 
Iterator iterator=set.iterator();  
 
while(it.hasNext())           {  
 
String oldStr=it.next();  
 
if(newStr.equals(oldStr)){  
 
isExists=true;  
 
}  
 
} 
</code></pre>
<p>Set的功能方法</p>
<p>Set具有与Collection完全一样的接口，因此没有任何额外的功能，不像前面有两个不同的List。实际上Set就是Collection,只是行为不同。(这是继承与多态思想的典型应用：表现不同的行为。)Set不保存重复的元素(至于如何判断元素相同则较为负责)</p>
<p>Set : 存入Set的每个元素都必须是唯一的，因为Set不保存重复元素。加入Set的元素必须定义equals()方法以确保对象的唯一性。Set与Collection有完全一样的接口。Set接口不保证维护元素的次序。</p>
<p>HashSet：为快速查找设计的Set。存入HashSet的对象必须定义hashCode()。<br>
TreeSet： 保存次序的Set, 底层为树结构。使用它可以从Set中提取有序的序列。<br>
LinkedHashSet：具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序)。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示。</p>
<h4 id="list列表">List(列表)</h4>
<p>List的特征是其元素以线性方式存储，集合中可以存放重复对象。</p>
<p>List接口主要实现类包括：</p>
<blockquote>
<ul>
<li>ArrayList() : 代表长度可以改变得数组。<font color="red">可以对元素进行随机的访问，向ArrayList()中插入与删除元素的速度慢。</font></li>
</ul>
</blockquote>
<ul>
<li>LinkedList(): 在实现中采用链表数据结构。<font color="red">插入和删除速度快，访问速度慢。</font></li>
</ul>
<p>对于List的随机访问来说，就是只随机来检索位于特定位置的元素。 List 的 get(int index) 方法放回集合中由参数index指定的索引位置的对象，下标从“0” 开始。</p>
<p>最基本的两种检索集合中的所有对象的方法：</p>
<ol>
<li>for循环和get()方法：</li>
</ol>
<pre><code class="language-java">for(int i=0; i&lt;list.size();i++){  
 
System.out.println(list.get(i));  
 
}  
</code></pre>
<ol start="2">
<li>使用 迭代器（Iterator）:</li>
</ol>
<pre><code class="language-java">Iterator it = list.iterator;

while(it.hashNext()) {
    System.out.println(it.next());
}
</code></pre>
<p>List的功能方法</p>
<p>实际上有两种List：<br>
一种是基本的ArrayList,其优点在于随机访问元素，<br>
另一种是更强大的LinkedList,它并不是为快速随机访问设计的，而是具有一套更通用的方法。</p>
<ul>
<li>List：次序是List最重要的特点：<font color="red">它保证维护元素特定的顺序。</font>List为Collection添加了许多方法，使得能够向List中间插入与移除元素(这只推荐LinkedList使用。)一个List可以生成ListIterator,使用它可以从两个方向遍历List,也可以从List中间插入和移除元 素。</li>
<li>ArrayList：由数组实现的List。允许对元素进行快速随机访问，但是向List中间插入与移除元素的速度很慢。ListIterator只应该用来由后向前遍历 ArrayList,而不是用来插入和移除元素。因为那比LinkedList开销要大很多。</li>
<li>LinkedList ：对顺序访问进行了优化，向List中间插入与删除的开销并不大。随机访问则相对较慢。(使用ArrayList代替。)还具有下列方法：addFirst(), addLast(), getFirst(), getLast(), removeFirst() 和 removeLast(), 这些方法 (没有在任何接口或基类中定义过)使得LinkedList可以当作堆栈、队列和双向队列使用。</li>
</ul>
<h4 id="map映射">Map(映射)</h4>
<p>Map 是一种把键对象和值对象映射的集合，它的每一个元素都包含一对键对象和值对象。 Map没有继承于Collection接口 从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</p>
<p>Map 的常用方法：</p>
<ol>
<li>添加，删除操作：</li>
</ol>
<pre><code class="language-java">Object put(Object key, Object value)： 向集合中加入元素   
Object remove(Object key)： 删除与KEY相关的元素   
void putAll(Map t)：  将来自特定映像的所有元素添加给该映像   
void clear()：从映像中删除所有映射
</code></pre>
<ol start="2">
<li>查询操作：</li>
</ol>
<p>Object get(Object key)：获得与关键字key相关的值 。Map集合中的键对象不允许重复，也就说，任意两个键对象通过equals()方法比较的结果都是false.，但是可以将任意多个键独享映射到同一个值对象上。</p>
<p>Map的功能方法</p>
<p>方法put(Object key, Object value)添加一个“值”(想要得东西)和与“值”相关联的“键”(key)(使用它来查找)。方法get(Object key)返回与给定“键”相关联的“值”。可以用containsKey()和containsValue()测试Map中是否包含某个“键”或“值”。 标准的Java类库中包含了几种不同的Map：HashMap, TreeMap, LinkedHashMap,<br>
WeakHashMap, IdentityHashMap。它们都有同样的基本接口Map，但是行为、效率、排序策略、保存对象的生命周期和判定“键”等价的策略等各不相同。</p>
<p>执行效率是Map的一个大问题。看看get()要做哪些事，就会明白为什么在ArrayList中搜索“键”是相当慢的。而这正是HashMap提高速度的地方。HashMap使用了特殊的值，称为“散列码”(hash code)，来取代对键的缓慢搜索。“散列码”是“相对唯一”用以代表对象的int值，它是通过将该对象的某些信息进行转换而生成的。所有Java对象都 能产生散列码，因为hashCode()是定义在基类Object中的方法。</p>
<p>HashMap就是使用对象的hashCode()进行快速查询的。此方法能够显着提高性能。</p>
<p>Map : 维护“键值对”的关联性，使你可以通过“键”查找“值”</p>
<p>HashMap：Map基于散列表的实现。插入和查询“键值对”的开销是固定的。可以通过构造器设置容量capacity和负载因子load factor，以调整容器的性能。</p>
<p>LinkedHashMap： 类似于HashMap，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用(LRU)的次序。只比HashMap慢一点。而在迭代访问时发而更快，因为它使用链表维护内部次序。</p>
<p>TreeMap ： 基于红黑树数据结构的实现。查看“键”或“键值对”时，它们会被排序(次序由Comparabel或Comparator决定)。TreeMap的特点在 于，你得到的结果是经过排序的。TreeMap是唯一的带有subMap()方法的Map，它可以返回一个子树。</p>
<p>WeakHashMao ：弱键(weak key)Map，Map中使用的对象也被允许释放: 这是为解决特殊问题设计的。如果没有map之外的引用指向某个“键”，则此“键”可以被垃圾收集器回收。</p>
<p>IdentifyHashMap： : 使用==代替equals()对“键”作比较的hash map。专为解决特殊问题而设计。</p>
<h4 id="区别">区别</h4>
<ol>
<li>Collection 和 Map 的区别</li>
</ol>
<blockquote>
<p>容器内每个为之所存储的元素个数不同。<br>
Collection类型者，每个位置只有一个元素。<br>
Map类型者，持有key-value pair,像个小型数据库。</p>
</blockquote>
<ol start="2">
<li>各自旗下的子类关系</li>
</ol>
<blockquote>
<p>--List: 将以特定次序存储元素。所以取出来的顺序可能和放入顺序不同<br>
--ArraList / LinkedList / Vector</p>
<p>--Set: 不能含有重复元素<br>
--HashSet / TreeSet</p>
<p>--Map<br>
--HashMap / HashTable / TreeMap</p>
</blockquote>
<ol start="3">
<li>其他特征</li>
</ol>
<p>List，Set，Map将持有对象一律视为Object型别。<br>
Collection、List、Set、Map都是接口，不能实例化。</p>
<p>继承自它们的 ArrayList, Vector, HashTable, HashMap是具象class，这些才可被实例化。</p>
<p>vector容器确切知道它所持有的对象隶属什么型别。vector不进行边界检查。</p>
<p><font color="red">总结</font></p>
<ol>
<li>如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。</li>
<li>如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。</li>
<li>在除需要排序时使用TreeSet,TreeMap外,都应使用HashSet,HashMap,因为他们的效率更高。</li>
<li>要特别注意对哈希表的操作，作为key的对象要正确复写equals和hashCode方法。</li>
<li>容器类仅能持有对象引用（指向对象的指针），而不是将对象信息copy一份至数列某位置。一旦将对象置入容器内，便损失了该对象的型别信息。</li>
<li>尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。<br>
<strong>注意：</strong><br>
1、Collection没有get()方法来取得某个元素。只能通过iterator()遍历元素。<br>
2、Set和Collection拥有一模一样的接口。<br>
3、List，可以通过get()方法来一次取出一个元素。使用数字来选择一堆对象中的一个，get(0)...。(add/get)<br>
4、一般使用ArrayList。用LinkedList构造堆栈stack、队列queue。<br>
5、Map用 put(k,v) / get(k)，还可以使用containsKey()/containsValue()来检查其中是否含有某个key/value。<br>
HashMap会利用对象的hashCode来快速找到key。<br>
6、Map中元素，可以将key序列、value序列单独抽取出来。<br>
使用keySet()抽取key序列，将map中的所有keys生成一个Set。<br>
使用values()抽取value序列，将map中的所有values生成一个Collection。<br>
为什么一个生成Set，一个生成Collection？那是因为，key总是独一无二的，value允许重复。</li>
</ol>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://jike-leisong.github.io//tag/java" class="tag">
                    Java
                  </a>
                
                  <a href="https://jike-leisong.github.io//tag/mian-shi-ti" class="tag">
                    面试题
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://jike-leisong.github.io//post/面试题">
                  <h3 class="post-title">
                    面试题
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
