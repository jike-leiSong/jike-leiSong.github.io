<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jike-leisong.github.io/</id>
    <title>itme.ink</title>
    <updated>2019-11-13T05:43:33.867Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jike-leisong.github.io/"/>
    <link rel="self" href="https://jike-leisong.github.io//atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jike-leisong.github.io//images/avatar.png</logo>
    <icon>https://jike-leisong.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, itme.ink</rights>
    <entry>
        <title type="html"><![CDATA[Sql Demo]]></title>
        <id>https://jike-leisong.github.io//post/Sql Demo</id>
        <link href="https://jike-leisong.github.io//post/Sql Demo">
        </link>
        <updated>2019-04-11T03:08:00.000Z</updated>
        <content type="html"><![CDATA[<p><strong>年龄大，记性不好，便于查询，故简单记录常用于此。</strong></p>
<ul>
<li>sql 模版</li>
</ul>
<pre><code class="language-sql">&lt;sql id=&quot;querySql&quot;&gt;
    &lt;if test=&quot;meterNoList.size() &gt; 0&quot;  &gt;
        AND t1.meter_no IN
        &lt;foreach collection=&quot;meterNoList&quot; index=&quot;index&quot; item=&quot;item&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;
            #{item}
        &lt;/foreach&gt;
    &lt;/if&gt;
    &lt;if test=&quot;startTime != null and startTime !='' and endTime != null and endTime !=''&quot; &gt;
        AND
        DATE_FORMAT(t1.read_time,'%Y-%m-%d') between DATE_FORMAT(#{startTime},'%Y-%m-%d') AND DATE_FORMAT(#{endTime},'%Y-%m-%d')
    &lt;/if&gt;
&lt;/sql&gt;
</code></pre>
<ul>
<li>choose-when</li>
</ul>
<pre><code class="language-sql">SELECT
    SUM( useQuantity) AS useQuantity,
    date,
    SUM( fees ) AS fees,
    SUM(lastMonthPercent) AS lastMonthPercent,
    SUM(samePeriodPercent) AS samePeriodPercent     
    FROM

&lt;choose&gt;
    &lt;when test=&quot;is == 2&quot;&gt;
        (   
        SELECT
            SUM( t1.use_quantity ) AS useQuantity,
            DATE_FORMAT(t1.read_time,'%Y-%m') AS date,
            SUM( t1.fees ) AS fees,
            '-' AS lastMonthPercent,
            '-' AS samePeriodPercent  
        FROM
            steam_meter_reading_day t1 
        WHERE
            t1.read_time BETWEEN DATE_ADD( curdate( ), INTERVAL - DAY ( curdate( ) ) + 1 DAY ) 
            AND date_sub( curdate( ), INTERVAL 1 DAY )
    
        UNION
    &lt;otherwise&gt;
        
    &lt;/otherwise&gt;
&lt;/choose&gt;
</code></pre>
<ul>
<li>批量更新</li>
</ul>
<pre><code class="language-sql">update t_customer  
&lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt;  
    
    &lt;trim prefix=&quot;c_name =case&quot; suffix=&quot;end,&quot;&gt;  
        &lt;foreach collection=&quot;list&quot; item=&quot;cus&quot;&gt;  
            &lt;if test=&quot;cus.name!=null&quot;&gt;  
                when id=#{cus.id} then #{cus.name}  
            &lt;/if&gt;  
        &lt;/foreach&gt;  
    &lt;/trim&gt;  
            &lt;/trim&gt;  
&lt;/trim&gt;  
&lt;where&gt;  
    &lt;foreach collection=&quot;list&quot; separator=&quot;or&quot; item=&quot;cus&quot;&gt;  
        id = #{cus.id}  
    &lt;/foreach&gt;  
&lt;/where&gt;  
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tomcat线程源码分析]]></title>
        <id>https://jike-leisong.github.io//post/Tomcat线程源码分析</id>
        <link href="https://jike-leisong.github.io//post/Tomcat线程源码分析">
        </link>
        <updated>2018-02-07T06:25:20.000Z</updated>
        <content type="html"><![CDATA[<h5 id="tomcat-线程">tomcat 线程</h5>
<ul>
<li>BIO</li>
<li>NIO</li>
<li>APR</li>
<li>AIO</li>
</ul>
<h5 id="各io说明">各IO说明：</h5>
<p><strong>BIO</strong></p>
<blockquote>
<p>阻塞式IO，即 Tomcat使用传统的 java.io 进行操作。该模式下每个请求都会创建一个线程，对性能开销大，不适合高并发场景。优点是稳定，适合连接数目小且固定架构。</p>
</blockquote>
<p><strong>NIO</strong></p>
<blockquote>
<p>非阻塞式IO，jdk1.4后实现的新IO。该模式基于多路复用选择器检测链接状态再通知线程处理，从而达到非阻塞的目的。比传统的BIO能更好的支持并发性能。Tomcat 8.0之后默认采用该模式。</p>
</blockquote>
<p><strong>APR</strong></p>
<blockquote>
<p>全称是Apache Portable Runtime/Apache （可移植性运行库）。是 Apache HTTP服务器的支持库。可以简单的理解为，tomcat以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作。使用需要编译安装APR库。</p>
</blockquote>
<p><strong>AIO</strong></p>
<blockquote>
<p>异步非阻塞式IO，jdk1.7后支持。与NIO不同在于不需要多路复用选择器。而是请求处理完进程进行回调通知，以继续执行后续操作。Tomcat 8.0 之后支持。</p>
</blockquote>
<h5 id="使用指定io模型的配置方式">使用指定IO模型的配置方式:</h5>
<p>配置 server.xml 文件当中的 <Connector protocol="HTTP/1.1"> 修改即可。</p>
<p>默认配置 8.0 protocol=“HTTP/1.1” 8.0 之前是 BIO 8.0 之后是NIO</p>
<p><strong>BIO</strong></p>
<blockquote>
<p>protocol=“org.apache.coyote.http11.<font color="red">Http11Protocol</font>“</p>
</blockquote>
<p><strong>NIO</strong></p>
<blockquote>
<p>protocol=”org.apache.coyote.http11.<font color="red">Http11NioProtocol</font>“</p>
</blockquote>
<p>*<em>AIO</em></p>
<blockquote>
<p>protocol=”org.apache.coyote.http11.<font color="red">Http11Nio2Protocol</font>“</p>
</blockquote>
<p><strong>APR</strong></p>
<blockquote>
<p>protocol=”org.apache.coyote.http11.<font color="red">Http11AprProtocol</font>“</p>
</blockquote>
<h5 id="bio-线程模型">BIO 线程模型</h5>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/2018-2-7-%E4%B8%8B%E5%8D%882_57_53.png" alt=""></figure>
<h5 id="bio-源码解读">BIO 源码解读</h5>
<ul>
<li>JIoEndpoint</li>
<li>Acceptor extends Runnable</li>
<li>SocketProcessor extends Runnable</li>
</ul>
<h5 id="nio-线程模型">NIO 线程模型</h5>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/2018-2-7-%E4%B8%8B%E5%8D%882_57_53.png" alt=""></figure>
<h5 id="nio-源码解读">NIO 源码解读</h5>
<ul>
<li>Acceptor extends Runnable</li>
<li>PollerEvent</li>
<li>Poller</li>
<li>SocketProcessor extends Runnable</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git常用命令速查表]]></title>
        <id>https://jike-leisong.github.io//post/Git常用命令速查表</id>
        <link href="https://jike-leisong.github.io//post/Git常用命令速查表">
        </link>
        <updated>2018-01-23T14:43:20.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/2018-1-23-%E4%B8%8B%E5%8D%8810_45_35.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IO与NIO线程模型Reactor模型Netty初探]]></title>
        <id>https://jike-leisong.github.io//post/IO与NIO线程模型Reactor模型Netty初探</id>
        <link href="https://jike-leisong.github.io//post/IO与NIO线程模型Reactor模型Netty初探">
        </link>
        <updated>2018-01-21T07:35:00.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img//2018-1-21-%E4%B8%8B%E5%8D%883_49_25.png" alt=""></figure>
<p><strong>网络进程</strong></p>
<blockquote>
<ul>
<li>两个进程间通信</li>
<li>CS</li>
</ul>
</blockquote>
<p><strong>BIO (Block IO)</strong></p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/2018-1-21-%E4%B8%8B%E5%8D%883_53_11.png" alt=""></figure>
<p><strong>BIO（Block IO）多线程版本</strong></p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/2018-1-21-%E4%B8%8B%E5%8D%883_53_59.png" alt=""></figure>
<p><strong>伪异步IO版本</strong></p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/2018-1-21-%E4%B8%8B%E5%8D%883_54_30.png" alt=""></figure>
<p><strong>整个BIO最主要的问题</strong></p>
<blockquote>
<p>每当一个新的客户端请求接入时，服务端必须创建一个线程来处理这个链路<br>
如果在高性能、高并发的场景下是无法使用的</p>
</blockquote>
<p><strong>NIO （Non Block IO (new IO)）</strong></p>
<blockquote>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/2018-1-21-%E4%B8%8B%E5%8D%883_57_03.png" alt=""></figure>
</blockquote>
<p><strong>NIO/单线程Reactor模型</strong></p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/2018-1-21-%E4%B8%8B%E5%8D%883_57_37.png" alt=""></figure>
<p><strong>多线程Reactor模型</strong></p>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/2018-1-21-%E4%B8%8B%E5%8D%883_58_04.png" alt=""></figure>
<p><strong>主从多线程Reactor模型</strong></p>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/2018-1-21-%E4%B8%8B%E5%8D%883_58_34.png" alt=""></figure>
<p><strong>IO 模型图</strong></p>
<blockquote>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/IO%E6%A8%A1%E5%9E%8B%E5%9B%BE.png" alt=""></figure>
</blockquote>
<p><strong>NIO 模型图</strong></p>
<blockquote>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/NIO%E6%A8%A1%E5%9E%8B%E5%9B%BE.png" alt=""></figure>
</blockquote>
<p><strong>IO多路复用、Select、epll</strong></p>
<blockquote>
<figure data-type="image" tabindex="11"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/%E6%89%A9%E5%B1%95.png" alt=""></figure>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot 嵌套jsp页面Whitelabel Error Page]]></title>
        <id>https://jike-leisong.github.io//post/Spring Boot 嵌套jsp页面Whitelabel Error Page</id>
        <link href="https://jike-leisong.github.io//post/Spring Boot 嵌套jsp页面Whitelabel Error Page">
        </link>
        <updated>2018-01-17T01:37:20.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h4 id="现象">现象</h4>
<blockquote>
<p>Spring boot 项目欠web，使用jsp，访问 http://localhost:8080/，页面 <strong>Whitelabel Error Page</strong></p>
</blockquote>
<h4 id="问题">问题</h4>
<blockquote>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/erroPage.jpg" alt=""></figure>
</blockquote>
<h4 id="解决">解决</h4>
<blockquote>
<p>修改 Working directory，点击1，选择2--<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>O</mi><mi>D</mi><mi>U</mi><mi>L</mi><msub><mi>E</mi><mi>D</mi></msub><mi>I</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">MODULE_DIR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">L</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>，如下图：</p>
</blockquote>
<blockquote>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/errorPage1.jpg" alt=""></figure>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mybatis invalid comparison]]></title>
        <id>https://jike-leisong.github.io//post/Mybatis invalid comparison</id>
        <link href="https://jike-leisong.github.io//post/Mybatis invalid comparison">
        </link>
        <updated>2018-01-12T14:50:20.000Z</updated>
        <content type="html"><![CDATA[<p><strong>原因：</strong></p>
<blockquote>
<p>这是一个根据list集合的查找数据的 sql，在接收list的时候加了判断 list ！= ‘'“”，引起了集合与Stirng类型的比较，故报错.</p>
</blockquote>
<p>错误代码：</p>
<pre><code>&lt;if test=&quot;list != null and list != ‘‘&quot;&gt;  
    and ul.loan_id in  
    &lt;foreach collection=&quot;list&quot; index=&quot;index&quot; item=&quot;loanIdList&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;  
      #{loanIdList}  
    &lt;/foreach&gt;  
&lt;/if&gt;
</code></pre>
<p>解决方案：   将判断条件改为 ： list.size &gt; 0</p>
<pre><code>&lt;if test=&quot;list != null and list.size &gt; 0&quot;&gt;  
    and ul.loan_id in  
    &lt;foreach collection=&quot;list&quot; index=&quot;index&quot; item=&quot;loanIdList&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;  
      #{loanIdList}  
    &lt;/foreach&gt;  
&lt;/if&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 多线程]]></title>
        <id>https://jike-leisong.github.io//post/Java多线程</id>
        <link href="https://jike-leisong.github.io//post/Java多线程">
        </link>
        <updated>2017-12-31T00:20:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="设计模式">设计模式</h3>
<ul>
<li>
<p>Immutable Object（不可变对象）模式</p>
</li>
<li>
<p>Guarded Suspension（保护性暂挂）模式</p>
</li>
<li>
<p>Two-phase Termination（两阶段终止）模式</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring AOP 详解]]></title>
        <id>https://jike-leisong.github.io//post/Spring AOP 详解</id>
        <link href="https://jike-leisong.github.io//post/Spring AOP 详解">
        </link>
        <updated>2017-12-25T08:56:20.000Z</updated>
        <content type="html"><![CDATA[<p>一.前言</p>
<pre><code>在以前的项目中，很少去关注spring aop的具体实现与理论，只是简单了解了一下什么是aop具体怎么用，看到了一篇博文写得还不错，就转载来学习一下，博文地址：http://www.cnblogs.com/xrq730/p/4919025.html
</code></pre>
<p><strong>AOP</strong></p>
<blockquote>
<p>AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
</blockquote>
<p>AOP技术恰恰相反，它利用一种称为&quot;横切&quot;的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为&quot;Aspect&quot;，即切面。所谓&quot;切面&quot;，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p>
<p>使用&quot;横切&quot;技术，AOP把软件系统分为两个部分：<font color="red">核心关注点</font>和<font color="red">横切关注点</font>。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如<font color="red">权限认证、日志、事物</font>。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<p><strong>AOP核心概念</strong></p>
<p>1、横切关注点</p>
<blockquote>
<p>对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点</p>
</blockquote>
<p>2、切面（aspect）</p>
<blockquote>
<p>类是对物体特征的抽象，切面就是对横切关注点的抽象</p>
</blockquote>
<p>3、连接点（joinpoint）</p>
<blockquote>
<p>被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</p>
</blockquote>
<p>4、切入点（pointcut）</p>
<blockquote>
<p>对连接点进行拦截的定义</p>
</blockquote>
<p>5、通知（advice）</p>
<blockquote>
<p>所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类</p>
</blockquote>
<p>6、目标对象</p>
<blockquote>
<p>代理的目标对象</p>
</blockquote>
<p>7、织入（weave）</p>
<blockquote>
<p>将切面应用到目标对象并导致代理对象创建的过程</p>
</blockquote>
<p>8、引入（introduction）</p>
<blockquote>
<p>在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段</p>
</blockquote>
<p>Spring对AOP的支持</p>
<p><font color="red">Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理。</font>因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring创建代理的规则为：</p>
<blockquote>
<p>1、<font color="red">默认使用Java动态代理来创建AOP代理</font>，这样就可以为任何接口实例创建代理了</p>
</blockquote>
<blockquote>
<p>2、<font color="red">当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理</font>，也可强制使用CGLIB</p>
</blockquote>
<p><strong>AOP编程其实是很简单的事情，纵观AOP编程，程序员只需要参与三个部分：</strong></p>
<blockquote>
<p>1、定义普通业务组件</p>
</blockquote>
<blockquote>
<p>2、定义切入点，一个切入点可能横切多个业务组件</p>
</blockquote>
<blockquote>
<p>3、定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作</p>
</blockquote>
<p>所以进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理，即：<font color="red">代理对象的方法=增强处理+被代理对象</font>的方法。</p>
<p>下面给出一个Spring AOP的.xml文件模板，名字叫做aop.xml，之后的内容都在aop.xml上进行扩展：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd&quot;&gt;
            
&lt;/beans&gt;
</code></pre>
<p><strong>基于Spring的AOP简单实现</strong></p>
<p>注意一下，在讲解之前，说明一点：使用Spring AOP，要成功运行起代码，只用Spring提供给开发者的jar包是不够的，请额外上网下载两个jar包：</p>
<p>1、aopalliance.jar</p>
<p>2、aspectjweaver.jar</p>
<p>开始讲解用Spring AOP的XML实现方式，先定义一个接口：</p>
<pre><code class="language-java">public interface HelloWorld
{
    void printHelloWorld();
    void doPrint();
}
</code></pre>
<p>定义两个接口实现类：</p>
<pre><code class="language-java">public class HelloWorldImpl1 implements HelloWorld
{
    public void printHelloWorld()
    {
        System.out.println(&quot;Enter HelloWorldImpl1.printHelloWorld()&quot;);
    }
    
    public void doPrint()
    {
        System.out.println(&quot;Enter HelloWorldImpl1.doPrint()&quot;);
        return ;
    }
}
</code></pre>
<pre><code class="language-java">public class HelloWorldImpl2 implements HelloWorld
{
    public void printHelloWorld()
    {
        System.out.println(&quot;Enter HelloWorldImpl2.printHelloWorld()&quot;);
    }
    
    public void doPrint()
    {
        System.out.println(&quot;Enter HelloWorldImpl2.doPrint()&quot;);
        return ;
    }
}
</code></pre>
<p>横切关注点，这里是打印时间：</p>
<pre><code class="language-java">public class TimeHandler
{
    public void printTime()
    {
        System.out.println(&quot;CurrentTime = &quot; + System.currentTimeMillis());
    }
}
</code></pre>
<p>有这三个类就可以实现一个简单的Spring AOP了，看一下aop.xml的配置：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd&quot;&gt;
        
        &lt;bean id=&quot;helloWorldImpl1&quot; class=&quot;com.xrq.aop.HelloWorldImpl1&quot; /&gt;
        &lt;bean id=&quot;helloWorldImpl2&quot; class=&quot;com.xrq.aop.HelloWorldImpl2&quot; /&gt;
        &lt;bean id=&quot;timeHandler&quot; class=&quot;com.xrq.aop.TimeHandler&quot; /&gt;
        
        &lt;aop:config&gt;
            &lt;aop:aspect id=&quot;time&quot; ref=&quot;timeHandler&quot;&gt;
                &lt;aop:pointcut id=&quot;addAllMethod&quot; expression=&quot;execution(* com.xrq.aop.HelloWorld.*(..))&quot; /&gt;
                &lt;aop:before method=&quot;printTime&quot; pointcut-ref=&quot;addAllMethod&quot; /&gt;
                &lt;aop:after method=&quot;printTime&quot; pointcut-ref=&quot;addAllMethod&quot; /&gt;
            &lt;/aop:aspect&gt;
        &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<p>写一个main函数调用一下：</p>
<pre><code class="language-java">public static void main(String[] args)
{
    ApplicationContext ctx = 
            new ClassPathXmlApplicationContext(&quot;aop.xml&quot;);
        
    HelloWorld hw1 = (HelloWorld)ctx.getBean(&quot;helloWorldImpl1&quot;);
    HelloWorld hw2 = (HelloWorld)ctx.getBean(&quot;helloWorldImpl2&quot;);
    hw1.printHelloWorld();
    System.out.println();
    hw1.doPrint();
    
    System.out.println();
    hw2.printHelloWorld();
    System.out.println();
    hw2.doPrint();
}
</code></pre>
<p>运行结果为：</p>
<pre><code>CurrentTime = 1446129611993
Enter HelloWorldImpl1.printHelloWorld()
CurrentTime = 1446129611993

CurrentTime = 1446129611994
Enter HelloWorldImpl1.doPrint()
CurrentTime = 1446129611994

CurrentTime = 1446129611994
Enter HelloWorldImpl2.printHelloWorld()
CurrentTime = 1446129611994

CurrentTime = 1446129611994
Enter HelloWorldImpl2.doPrint()
CurrentTime = 1446129611994
</code></pre>
<p>看到给HelloWorld接口的两个实现类的所有方法都加上了代理，代理内容就是打印时间</p>
<p><strong>基于Spring的AOP使用其他细节</strong></p>
<p>1、增加一个横切关注点，打印日志，Java类为：</p>
<pre><code class="language-java">public class LogHandler
{
    public void LogBefore()
    {
        System.out.println(&quot;Log before method&quot;);
    }
    
    public void LogAfter()
    {
        System.out.println(&quot;Log after method&quot;);
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd&quot;&gt;
        
        &lt;bean id=&quot;helloWorldImpl1&quot; class=&quot;com.xrq.aop.HelloWorldImpl1&quot; /&gt;
        &lt;bean id=&quot;helloWorldImpl2&quot; class=&quot;com.xrq.aop.HelloWorldImpl2&quot; /&gt;
        &lt;bean id=&quot;timeHandler&quot; class=&quot;com.xrq.aop.TimeHandler&quot; /&gt;
        &lt;bean id=&quot;logHandler&quot; class=&quot;com.xrq.aop.LogHandler&quot; /&gt;
        
        &lt;aop:config&gt;
            &lt;aop:aspect id=&quot;time&quot; ref=&quot;timeHandler&quot; order=&quot;1&quot;&gt;
                &lt;aop:pointcut id=&quot;addTime&quot; expression=&quot;execution(* com.xrq.aop.HelloWorld.*(..))&quot; /&gt;
                &lt;aop:before method=&quot;printTime&quot; pointcut-ref=&quot;addTime&quot; /&gt;
                &lt;aop:after method=&quot;printTime&quot; pointcut-ref=&quot;addTime&quot; /&gt;
            &lt;/aop:aspect&gt;
            &lt;aop:aspect id=&quot;log&quot; ref=&quot;logHandler&quot; order=&quot;2&quot;&gt;
                &lt;aop:pointcut id=&quot;printLog&quot; expression=&quot;execution(* com.xrq.aop.HelloWorld.*(..))&quot; /&gt;
                &lt;aop:before method=&quot;LogBefore&quot; pointcut-ref=&quot;printLog&quot; /&gt;
                &lt;aop:after method=&quot;LogAfter&quot; pointcut-ref=&quot;printLog&quot; /&gt;
            &lt;/aop:aspect&gt;
        &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<p>测试类不变，打印结果为：</p>
<pre><code>CurrentTime = 1446130273734
Log before method
Enter HelloWorldImpl1.printHelloWorld()
Log after method
CurrentTime = 1446130273735

CurrentTime = 1446130273736
Log before method
Enter HelloWorldImpl1.doPrint()
Log after method
CurrentTime = 1446130273736

CurrentTime = 1446130273736
Log before method
Enter HelloWorldImpl2.printHelloWorld()
Log after method
CurrentTime = 1446130273736

CurrentTime = 1446130273737
Log before method
Enter HelloWorldImpl2.doPrint()
Log after method
CurrentTime = 1446130273737
</code></pre>
<p>要想让logHandler在timeHandler前使用有两个办法：</p>
<blockquote>
<p>（1）aspect里面有一个order属性，order属性的数字就是横切关注点的顺序</p>
</blockquote>
<blockquote>
<p>（2）把logHandler定义在timeHandler前面，Spring默认以aspect的定义顺序作为织入顺序</p>
</blockquote>
<p>2、我只想织入接口中的某些方法</p>
<p>修改一下pointcut的expression就好了：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd&quot;&gt;
        
        &lt;bean id=&quot;helloWorldImpl1&quot; class=&quot;com.xrq.aop.HelloWorldImpl1&quot; /&gt;
        &lt;bean id=&quot;helloWorldImpl2&quot; class=&quot;com.xrq.aop.HelloWorldImpl2&quot; /&gt;
        &lt;bean id=&quot;timeHandler&quot; class=&quot;com.xrq.aop.TimeHandler&quot; /&gt;
        &lt;bean id=&quot;logHandler&quot; class=&quot;com.xrq.aop.LogHandler&quot; /&gt;
        
        &lt;aop:config&gt;
            &lt;aop:aspect id=&quot;time&quot; ref=&quot;timeHandler&quot; order=&quot;1&quot;&gt;
                &lt;aop:pointcut id=&quot;addTime&quot; expression=&quot;execution(* com.xrq.aop.HelloWorld.print*(..))&quot; /&gt;
                &lt;aop:before method=&quot;printTime&quot; pointcut-ref=&quot;addTime&quot; /&gt;
                &lt;aop:after method=&quot;printTime&quot; pointcut-ref=&quot;addTime&quot; /&gt;
            &lt;/aop:aspect&gt;
            &lt;aop:aspect id=&quot;log&quot; ref=&quot;logHandler&quot; order=&quot;2&quot;&gt;
                &lt;aop:pointcut id=&quot;printLog&quot; expression=&quot;execution(* com.xrq.aop.HelloWorld.do*(..))&quot; /&gt;
                &lt;aop:before method=&quot;LogBefore&quot; pointcut-ref=&quot;printLog&quot; /&gt;
                &lt;aop:after method=&quot;LogAfter&quot; pointcut-ref=&quot;printLog&quot; /&gt;
            &lt;/aop:aspect&gt;
        &lt;/aop:config&gt;
&lt;/beans&gt;
</code></pre>
<p>表示timeHandler只会织入HelloWorld接口print开头的方法，logHandler只会织入HelloWorld接口do开头的方法</p>
<p><strong>3、强制使用CGLIB生成代理</strong></p>
<p>前面说过Spring使用动态代理或是CGLIB生成代理是有规则的，高版本的Spring会自动选择是使用动态代理还是CGLIB生成代理内容，当然我们也可以强制使用CGLIB生成代理，那就是<a href="aop:config">aop:config</a>里面有一个&quot;proxy-target-class&quot;属性，这个属性值如果被设置为true，那么基于类的代理将起作用，如果proxy-target-class被设置为false或者这个属性被省略，那么基于接口的代理将起作用</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java多线程Executor框架详解]]></title>
        <id>https://jike-leisong.github.io//post/Java多线程Executor框架详解</id>
        <link href="https://jike-leisong.github.io//post/Java多线程Executor框架详解">
        </link>
        <updated>2017-12-18T14:32:20.000Z</updated>
        <content type="html"><![CDATA[<p>在Java中，<font color="red">使用线程来异步执行任务。</font>Java线程的创建与销毁需要一定的开销，如果我们为每一个任务创建一个新的线程来执行，这些线程的创建与销毁将<font color="red">消耗大量的计算机资源。</font>同时，为每一个任务创建一个新线程来执行，这种策略可能会使处于高负荷状态的应用最终崩溃。</p>
<p>Java线程既是工作单元，也是执行单元。从Jdk1.5开始，把<font color="red">工作单元</font>和<font color="red">执行机制</font>分离开来。<br>
工作单元包括：<font color="red">Runnable 和 Callable</font>，而执行机制由 Executor 框架提供。</p>
<h4 id="executor框架简介">Executor框架简介</h4>
<hr>
<p><strong>Executor框架的两级调度模型</strong></p>
<p>在HotSpot VM的线程模型中，Java线程被一对一映射为本地操作系统线程。Java线程启动时会创建一个本地操作系统线程；当Java线程终止时，这个操作系统线程也会被回收。操作系统会调用所有线程将他们分配给可用的CPU。</p>
<p>可以将此种模式分为两层，在上层，Java多线程程序通常把应用程序分解为若干任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。</p>
<p>两级调度模型示意图：</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/Executor.png" alt=""></figure>
<p>从图中看出，该框架用来控制应用程序的上层调度（下层调度由操作系统内核控制，不受应用程序的控制）。</p>
<p><strong>Executor框架的结构和成员</strong></p>
<ul>
<li>Executor框架的结构</li>
</ul>
<ol>
<li>任务</li>
</ol>
<blockquote>
<p>包括被执行任务需要实现的接口：Runnable 接口 和 Callable 接口</p>
</blockquote>
<ol start="2">
<li>任务的执行</li>
</ol>
<blockquote>
<p>包括任务执行机制的核心接口 Executor，以及继承自 Executor 的 ExecutorService 接口。<br>
Executor框架有两个关键类实现了ExecutorService接口：ThreadPoolExecutor 和 ScheduledThreadPoolExecutor</p>
</blockquote>
<ol start="3">
<li>异步计算结果</li>
</ol>
<blockquote>
<p>包括 Future 和 实现 Future 接口的 FutureTask 类。</p>
</blockquote>
<ul>
<li>Executor框架的类与接口</li>
</ul>
<p>示意图：</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/Executor-1.png" alt=""></figure>
<blockquote>
<ul>
<li>Executor 是一个接口，它是 Executor 框架的基础，它将 <font color="red">任务的提交</font>和<font color="red">任务的执行</font>分离。</li>
<li>ThreadPoolExecutor 是线程池的核心实现类，用来执行被提交的任务。</li>
<li>ScheduledThreadPoolExecutor 是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。ScheduledThreadPoolExecutor 比 Timer 更灵活，更强大。</li>
<li>Future 接口和它的实现类 FutureTask 类，代表异步的计算结果。</li>
<li>Runnable 和 Callable 接口的实现类，都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。</li>
</ul>
</blockquote>
<p><strong>Executor框架的使用</strong></p>
<p>先来看个图：</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/Executor-2.png" alt=""></figure>
<ol>
<li>主线程首先要创建实现 Runnable 接口或 Callable 接口的任务对象。工具类 Executors 可以把一个 Runnable 对象封装为一个 Callable 接口。</li>
</ol>
<pre><code class="language-java">Executors.callable(Runnale task);
或
Executors.callable(Runnable task, Object resule);
</code></pre>
<ol start="2">
<li>然后可以把 Runnable 对象直接交给 ExecutorService 执行。</li>
</ol>
<pre><code class="language-java">ExecutorService.execute(Runnable command);
或者也可以把Runnable对象或Callable对象提交给ExecutorService执行
ExecutorService.submit(Runnable task);
</code></pre>
<p>如果执行 ExecutorService.submit(...),ExecutorService将返回一个实现 Future 接口的对象(到目前为止的JDK中，返回的是FutureTask对象)。由于 FutureTask 实现了 Runnable 接口，我们可以创建 FutureTask 类，然后直接交给 ExecutorService 执行。</p>
<ol start="3">
<li>最后，主线程可以执行 FutureTask.get() 方法来等待任务的执行完成。主线程也可以执行 FutureTask.cancel(boolean mayInterruptIfRunning)来取消此任务的执行。</li>
</ol>
<h4 id="threadpoolexecutor详解">ThreadPoolExecutor详解</h4>
<hr>
<p>Executor框架最核心的类是ThreadPoolExecutor</p>
<p><strong>ThreadPoolExecutor的组件构成</strong></p>
<ul>
<li>corePool：核心线程池大小</li>
<li>maximumpool：最大线程池大小</li>
<li>BlockingQueue：用来暂时保存任务的工作队列</li>
<li>RejectedExecutionHandler：当ThreadPoolExecutor已经关闭或ThreadPoolExecutor已经饱和时(达到了最大线程池的大小且工作队列已满)，execute()方法将要调用的Handler。</li>
</ul>
<p><strong>Executor 可 以 创 建 3 种 类 型 的 ThreadPoolExecutor 线 程 池：</strong></p>
<ol>
<li>FixedThreadPool</li>
</ol>
<blockquote>
<p>创建固定长度的线程池，每次提交任务创建一个线程，直到达到线程池的最大数量，线程池的大小不在变化。<br>
这个线程池可以创建固定的线程数的线程池。<font color="red">特点是可以重用固定数量线程的线程池</font>。它的构造源码如下：</p>
</blockquote>
<pre><code class="language-java">public static ExecutorService newFixedThreadPool(int nThreads) { 
        return new ThreadPoolExecutor(nThreads, nThreads, 0L,
                                      TimeUnit.MILLISECONDS, 
                                      new LinkedBlockingQueue&lt;Runnable&gt;()); 
} 
</code></pre>
<ul>
<li>FixedThreadPool的corePoolSize和maxiumPoolSize都被设置为创建FixedThreadPool时指定的参数nThreads。</li>
<li>0L则表示当线程池中的线程数量操作核心线程的数量时，多余的线程将被立即停止</li>
<li>最后一个参数表示FixedThreadPool使用了无界队列LinkedBlockingQueue作为线程池的做工队列，由于是无界的，当线程池的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池的线程数量不会超过corePoolSize，同时maxiumPoolSize也就变成了一个无效的参数，并且运行中的线程池并不会拒绝任务。</li>
</ul>
<p>FixedThreadPool运行图如下:</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/Executor-3.png" alt=""></figure>
<p>执行过程如下：</p>
<blockquote>
<ol>
<li>如果当前工作中的线程数少于corePool的数量，就创建新的线程来执行任务。</li>
<li>当线程池的工作中的线程数量达到了corePool，则将任务加入到 LinkedBlockingQueue。</li>
<li>线程执行完1中的任务后从队列中去任务。</li>
</ol>
</blockquote>
<p>注意：<font color="red">LinkedBlockingQueue是无界队列，所以可以一直添加新任务到线程池。</font></p>
<ol start="2">
<li>SingleThreadExecutor</li>
</ol>
<p>SingleThreadExecutor是使用单个worker线程的Executor。<font color="red">特点是使用单个工作线程执行任务。</font>它的构造源码如下：</p>
<pre><code class="language-java">public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre>
<p>SingleThreadExecutor的corePoolSize和maxiumPoolSize都被设置1。<br>
其他参数均与FixedThreadPool相同，其运行图如下：</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/Executor-4.png" alt=""></figure>
<p>执行过程如下：</p>
<blockquote>
<ol>
<li>如果当前工作中的线程数少于corePool的数量，就创建新的线程来执行任务。</li>
<li>当线程池的工作中的线程数量达到了corePool，则将任务加入到 LinkedBlockingQueue。</li>
<li>线程执行完1中的任务后从队列中去任务。</li>
</ol>
</blockquote>
<p>注意：<font color="red">LinkedBlockingQueue是无界队列，所以可以一直添加新任务到线程池。</font></p>
<ol start="3">
<li>CachedThreadPool</li>
</ol>
<p>CachedThreadPool是一个”无限“容量的线程池，它会根据需要创建新线程。<font color="red">特点是可以根据需要来创建新的线程执行任务，没有特定的corePool。</font>下面是它的构造方法：</p>
<pre><code class="language-java"> public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre>
<p>CachedThreadPool的corePoolSize被设置为0，即corePool为空；maximumPoolSize被设置为Integer.MAX_VALUE，即maximum是无界的。这里keepAliveTime设置为60秒，意味着空闲的线程最多可以等待任务60秒，否则将被回收。</p>
<p>CachedThreadPool使用没有容量的SynchronousQueue作为主线程池的工作队列，它是一个没有容量的阻塞队列。每个插入操作必须等待另一个线程的对应移除操作。这意味着，<font color="red">如果主线程提交任务的速度高于线程池中处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU资源。</font>其运行图如下：</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/jike-leiSong/img/master/img/Executor-5.png" alt=""></figure>
<p>执行过程如下：</p>
<blockquote>
<p>1.首先执行SynchronousQueue.offer(Runnable task)。如果在当前的线程池中有空闲的线程正在执行SynchronousQueue.poll()，那么主线程执行的offer操作与空闲线程执行的poll操作配对成功，主线程把任务交给空闲线程执行。，execute()方法执行成功，否则执行步骤2<br>
2.当线程池为空(初始maximumPool为空)或没有空闲线程时，配对失败，将没有线程执行SynchronousQueue.poll操作。这种情况下，线程池会创建一个新的线程执行任务。<br>
3.在创建完新的线程以后，将会执行poll操作。当步骤2的线程执行完成后，将等待60秒，如果此时主线程提交了一个新任务，那么这个空闲线程将执行新任务，否则被回收。因此长时间不提交任务的CachedThreadPool不会占用系统资源。</p>
</blockquote>
<p>SynchronousQueue是一个不存储元素阻塞队列，每次要进行offer操作时必须等待poll操作，否则不能继续添加元素。</p>
<p>参考书籍：《Java并发编程的艺术》，《Java并发编程实战》，《Java高并发程序设计》</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring中配置数据源的4种形式]]></title>
        <id>https://jike-leisong.github.io//post/Spring中配置数据源的4种形式</id>
        <link href="https://jike-leisong.github.io//post/Spring中配置数据源的4种形式">
        </link>
        <updated>2017-12-17T12:08:20.000Z</updated>
        <content type="html"><![CDATA[<p>不管采用何种持久化技术，都需要定义数据源。Spring中提供了4种不同形式的数据源配置方式：<br>
spring自带的数据源(DriverManagerDataSource)，DBCP数据源，C3P0数据源,JNDI数据源。</p>
<p><strong>1.spring自带的数据源</strong></p>
<p>DriverManagerDataSource<br>
XML代码：</p>
<pre><code class="language-xml">&lt;bean id=&quot;dataSource&quot;     
      class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;     
    &lt;property name=&quot;driverClassName&quot; value=&quot;oracle.jdbc.driver.OracleDriver&quot; /&gt;  
    &lt;property name=&quot;url&quot; value=&quot;jdbc:oracle:thin:@172.19.34.6:1521:ORCL&quot; /&gt;  
    &lt;property name=&quot;username&quot; value=&quot;orclight&quot; /&gt;     
    &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;  
&lt;/bean&gt;  
</code></pre>
<p><strong>2.DBCP数据源</strong></p>
<p>DBCP的配置依赖于2个jar包commons-dbcp.jar，commons-pool.jar。<br>
XML代码:</p>
<pre><code class="language-xml">&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;         
        destroy-method=&quot;close&quot;&gt;         
    &lt;property name=&quot;driverClassName&quot; value=&quot;oracle.jdbc.driver.OracleDriver&quot; /&gt;  
    &lt;property name=&quot;url&quot; value=&quot;jdbc:oracle:thin:@172.19.34.6:1521:ORCL&quot; /&gt;  
    &lt;property name=&quot;username&quot; value=&quot;orclight&quot; /&gt;     
    &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;        
&lt;/bean&gt;   
</code></pre>
<p>上面代码的解释：<br>
BasicDataSource提供了close()方法关闭数据源，所以必须设定destroy-method=”close”属性， 以便Spring容器关闭时，数据源能够正常关闭。除以上必须的数据源属性外，还有一些常用的属性：</p>
<blockquote>
<p>defaultAutoCommit：设置从数据源中返回的连接是否采用自动提交机制，默认值为 true；<br>
defaultReadOnly：设置数据源是否仅能执行只读操作， 默认值为 false；<br>
maxActive：最大连接数据库连接数，设置为0时，表示没有限制；<br>
maxIdle：最大等待连接中的数量，设置为0时，表示没有限制；<br>
maxWait：最大等待秒数，单位为毫秒， 超过时间会报出错误信息；<br>
validationQuery：用于验证连接是否成功的查询SQL语句，SQL语句必须至少要返回一行数据， 如你可以简单地设置为：“select count(*) from user”；<br>
removeAbandoned：是否自我中断，默认是 false ；<br>
removeAbandonedTimeout：几秒后数据连接会自动断开，在removeAbandoned为true，提供该值；<br>
logAbandoned：是否记录中断事件， 默认为 false；</p>
</blockquote>
<p><strong>3.C3P0数据源</strong></p>
<p>C3P0是一个开放源代码的JDBC数据源实现项目，C3P0依赖于jar包c3p0.jar。<br>
XML代码：</p>
<pre><code class="language-xml">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;         
            destroy-method=&quot;close&quot;&gt;        
        &lt;property name=&quot;driverClass&quot; value=&quot; oracle.jdbc.driver.OracleDriver &quot;/&gt;        
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:oracle:thin:@172.19.34.6:1521:ORCL&quot;/&gt;        
        &lt;property name=&quot;user&quot; value=&quot;orclight&quot;/&gt;        
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;        
    &lt;/bean&gt;
</code></pre>
<p>ComboPooledDataSource和BasicDataSource一样提供了一个用于关闭数据源的close()方法，这样我们就可以保证Spring容器关闭时数据源能够成功释放。<br>
C3P0拥有比DBCP更丰富的配置属性，通过这些属性，可以对数据源进行各种有效的控制：</p>
<blockquote>
<p>acquireIncrement：当连接池中的连接用完时，C3P0一次性创建新连接的数目；<br>
acquireRetryAttempts：定义在从数据库获取新连接失败后重复尝试获取的次数，默认为30；<br>
acquireRetryDelay：两次连接中间隔时间，单位毫秒，默认为1000；<br>
autoCommitOnClose：连接关闭时默认将所有未提交的操作回滚。默认为false；<br>
automaticTestTable： C3P0将建一张名为Test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数，那么属性preferredTestQuery将被忽略。你 不能在这张Test表上进行任何操作，它将中为C3P0测试所用，默认为null；<br>
breakAfterAcquireFailure：获取连接失败将会引起所有等待获取连接的线程抛出异常。但是数据源仍有效保留，并在下次调   用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试获取连接失败后该数据源将申明已断开并永久关闭。默认为 false；<br>
checkoutTimeout：当连接池用完时客户端调用getConnection()后等待获取新连接的时间，超时后将抛出SQLException，如设为0则无限期等待。单位毫秒，默认为0；<br>
connectionTesterClassName： 通过实现ConnectionTester或QueryConnectionTester的类来测试连接，类名需设置为全限定名。默认为 com.mchange.v2.C3P0.impl.DefaultConnectionTester；<br>
idleConnectionTestPeriod：隔多少秒检查所有连接池中的空闲连接，默认为0表示不检查；<br>
initialPoolSize：初始化时创建的连接数，应在minPoolSize与maxPoolSize之间取值。默认为3；<br>
maxIdleTime：最大空闲时间，超过空闲时间的连接将被丢弃。为0或负数则永不丢弃。默认为0；<br>
maxPoolSize：连接池中保留的最大连接数。默认为15；<br>
maxStatements：JDBC的标准参数，用以控制数据源内加载的PreparedStatement数量。但由于预缓存的Statement属 于单个Connection而不是整个连接池。所以设置这个参数需要考虑到多方面的因素，如果maxStatements与 maxStatementsPerConnection均为0，则缓存被关闭。默认为0；<br>
maxStatementsPerConnection：连接池内单个连接所拥有的最大缓存Statement数。默认为0；<br>
numHelperThreads：C3P0是异步操作的，缓慢的JDBC操作通过帮助进程完成。扩展这些操作可以有效的提升性能，通过多线程实现多个操作同时被执行。默认为3；<br>
preferredTestQuery：定义所有连接测试都执行的测试语句。在使用连接测试的情况下这个参数能显著提高测试速度。测试的表必须在初始数据源的时候就存在。默认为null；<br>
propertyCycle： 用户修改系统配置参数执行前最多等待的秒数。默认为300；<br>
testConnectionOnCheckout：因性能消耗大请只在需要的时候使用它。如果设为true那么在每个connection提交的时候都 将校验其有效性。建议使用idleConnectionTestPeriod或automaticTestTable<br>
等方法来提升连接测试的性能。默认为false；<br>
testConnectionOnCheckin：如果设为true那么在取得连接的同时将校验连接的有效性。默认为false。</p>
</blockquote>
<p><strong>4.JNDI数据源</strong></p>
<p>如果应用配置在高性能的应用服务器（如WebLogic或Websphere,tomcat等）上，我们可能更希望使用应用服务器本身提供的数据源。应用服务器的数据源 使用JNDI开放调用者使用，Spring为此专门提供引用JNDI资源的JndiObjectFactoryBean类。<br>
xml 代码：</p>
<pre><code class="language-xml">&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jndi.JndiObjectFactoryBean&quot;&gt;        
        &lt;property name=&quot;jndiName&quot; value=&quot;java:comp/env/jdbc/orclight&quot;/&gt;        
&lt;/bean&gt; 
</code></pre>
<pre><code class="language-xml">&lt;beans xmlns=http://www.springframework.org/schema/beans      
xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance      
xmlns:jee=http://www.springframework.org/schema/jee      
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       
http://www.springframework.org/schema/beans/spring-beans-2.0.xsd       
http://www.springframework.org/schema/jee      
http://www.springframework.org/schema/jee/spring-jee-2.0.xsd&quot;&gt;        
    &lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot; java:comp/env/jdbc/orclight&quot;/&gt;        
&lt;/beans&gt; 
</code></pre>
]]></content>
    </entry>
</feed>